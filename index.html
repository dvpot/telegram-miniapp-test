<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Telegram Mini App ‚Äî English Words</title>

  <!-- –ü–æ–¥–∫–ª—é—á–∞–µ–º —Å—Ç–∏–ª–∏ (–æ—Ç–¥–µ–ª—å–Ω—ã–π —Ñ–∞–π–ª styles.css) -->
  <link rel="stylesheet" href="styles.css">
  <!-- Telegram WebApp (–µ—Å–ª–∏ –¥–æ—Å—Ç—É–ø–Ω–æ) -->
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
</head>
<body>
  <!-- –û—Å–Ω–æ–≤–Ω–∞—è –æ–±–æ–ª–æ—á–∫–∞ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è -->
  <div class="app">
    <div class="card">

      <!-- –ö–æ–Ω—Ç–µ–Ω—Ç–Ω–∞—è –æ–±–ª–∞—Å—Ç—å (–≤–º–µ—Å—Ç–µ —Å –∫–∞—Ä—Ç–∏–Ω–∫–æ–π, —Å–ª–æ–≤–∞–º–∏ –∏ –ø—Ä.)
           –∫–Ω–æ–ø–∫–∞ "–°–ª–µ–¥—É—é—â–µ–µ —Å–ª–æ–≤–æ" –≤—ã–Ω–µ—Å–µ–Ω–∞ –Ω–∏–∂–µ, —á—Ç–æ–±—ã –±—ã—Ç—å –≤–Ω–∏–∑—É –∫–∞—Ä—Ç–æ—á–∫–∏ -->
      <div class="content">

        <!-- –•–µ–¥–µ—Ä: –∏–º—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (–±–µ—Ä—ë–º –∏–∑ Telegram WebApp –µ—Å–ª–∏ –¥–æ—Å—Ç—É–ø–Ω–æ) -->
        <div class="header">
          <div id="username" class="username">–ü—Ä–∏–≤–µ—Ç!</div>
        </div>

        <!-- –ë–ª–æ–∫ –¥–ª—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è / —Ü–≤–µ—Ç–Ω–æ–≥–æ —Ñ–æ–Ω–∞ / –∑–∞–≥–ª—É—à–∫–∏.
             –°–æ–¥–µ—Ä–∂–∏—Ç placeholder –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é. -->
        <div id="imageArea" class="image-area" aria-live="polite">
          <div id="imagePlaceholder" class="image-placeholder">–ö–∞—Ä—Ç–∏–Ω–∫–∞ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç</div>
        </div>

        <!-- –¶–µ–Ω—Ç—Ä–∞–ª—å–Ω–∞—è —á–∞—Å—Ç—å: –∞–Ω–≥–ª–∏–π—Å–∫–æ–µ —Å–ª–æ–≤–æ + —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ü–∏—è + EN-–∫–Ω–æ–ø–∫–∞ (—Å–ø—Ä–∞–≤–∞) -->
        <div class="center">
          <div id="wordField" class="field" role="button" tabindex="0" aria-label="–ü–æ–∫–∞–∑–∞—Ç—å –∞–Ω–≥–ª–∏–π—Å–∫–æ–µ —Å–ª–æ–≤–æ">
            <div class="field-row">
              <div class="word-col">
                <p id="wordText" class="word-text">---</p>
                <p id="transText" class="trans-text">---</p>
              </div>

              <!-- EN small button: —Å–∫—Ä—ã—Ç–∞ –¥–æ —Ä–∞—Å–∫—Ä—ã—Ç–∏—è -->
              <button id="speakEN_small" class="tts-btn small" aria-label="–û–∑–≤—É—á–∏—Ç—å –∞–Ω–≥–ª–∏–π—Å–∫–æ–µ —Å–ª–æ–≤–æ">üîä</button>
            </div>
          </div>

          <!-- –ü–µ—Ä–µ–≤–æ–¥ + RU button (—Å–ø—Ä–∞–≤–∞, –≤–∏–¥–Ω–∞ –≤—Å–µ–≥–¥–∞) -->
          <div class="translation-field" aria-live="polite">
            <p id="translationText" class="translation-text">---</p>
            <button id="speakRU_small" class="tts-btn small" aria-label="–û–∑–≤—É—á–∏—Ç—å –ø–µ—Ä–µ–≤–æ–¥">üîä</button>
          </div>
        </div>
      </div>

      <!-- –ö–Ω–æ–ø–∫–∞ "–°–ª–µ–¥—É—é—â–µ–µ —Å–ª–æ–≤–æ" –≤—Å–µ–≥–¥–∞ –≤–Ω–∏–∑—É –∫–∞—Ä—Ç–æ—á–∫–∏ -->
      <button id="nextBtn" class="btn" aria-label="–°–ª–µ–¥—É—é—â–µ–µ —Å–ª–æ–≤–æ">–°–ª–µ–¥—É—é—â–µ–µ —Å–ª–æ–≤–æ</button>
    </div>
  </div>

  <!-- –ü–æ–¥–∫–ª—é—á–∞–µ–º JS (–æ—Ç–¥–µ–ª—å–Ω—ã–π —Ñ–∞–π–ª app.js)
  <script src="app.js"></script> -->

    <!-- –í–°–¢–†–û–ï–ù–ù–´–ô APP.JS -->
  <script>

    const tg = window.Telegram?.WebApp;
    if (tg) tg.ready();

    const usernameEl = document.getElementById('username');
    const imageArea = document.getElementById('imageArea');
    const wordField = document.getElementById('wordField');
    const wordText = document.getElementById('wordText');
    const transText = document.getElementById('transText');
    const translationText = document.getElementById('translationText');
    const speakENBtn = document.getElementById('speakEN_small');
    const speakRUBtn = document.getElementById('speakRU_small');
    const nextBtn = document.getElementById('nextBtn');

    const user = tg?.initDataUnsafe?.user;
    if (user) usernameEl.textContent = `–ü—Ä–∏–≤–µ—Ç, ${user.first_name || user.username}!`;

    let words = [];
    let current = null;
    let revealed = false;

    function colorForWord(word){
      if (!word) return null;
      const key = word.toLowerCase().trim();
      const map = {
        red:"red", blue:"blue", green:"green", yellow:"yellow",
        pink:"pink", purple:"purple", black:"black", white:"white",
        brown:"brown", grey:"grey", gray:"gray", orange:"orange",
        golden:"gold", gold:"gold", silver:"silver",
        dark:"#111", light:"#eee", "sky blue":"skyblue", skyblue:"skyblue"
      };
      return map[key] || null;
    }

    function imagePathOrNull(src){
      if (!src || !src.trim()) return null;
      return src.trim();
    }

    function showTranslationAsImageText(translation){
      const label = document.createElement('div');
      label.className = 'image-placeholder';
      label.textContent = translation ? translation.toUpperCase() : '‚Äî';
      imageArea.style.background = '#f3f4f6';
      imageArea.appendChild(label);
    }

    function setImageContent(src, translation, word){
      imageArea.innerHTML = '';
      imageArea.style.background = '';

      const color = colorForWord(word);
      if (color){
        imageArea.style.background = color;
        const label = document.createElement('div');
        label.className = 'image-placeholder';
        label.textContent = '';
        imageArea.appendChild(label);
        return;
      }

      const imgPath = imagePathOrNull(src);
      if (imgPath){
        const img = document.createElement('img');
        img.src = imgPath;
        img.alt = word || translation || 'image';
        img.onerror = () => {
          imageArea.innerHTML = '';
          showTranslationAsImageText(translation);
        };
        imageArea.appendChild(img);
        return;
      }

      showTranslationAsImageText(translation);
    }

    async function loadWords(){
      try{
        const r = await fetch('words.json', { cache: 'no-store' });
        words = await r.json();
      }catch(e){
        console.error('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ words.json', e);
        words = [];
      }
    }

    function getVoice(prefix){
      const voices = speechSynthesis.getVoices();
      if (!voices.length) return null;
      let v = voices.find(x => x.lang?.toLowerCase().startsWith(prefix));
      if (v) return v;
      v = voices.find(x => x.lang?.toLowerCase().startsWith('en'));
      return v || voices[0];
    }

    function speak(text, lang){
      if (!text) return;
      if (!('speechSynthesis' in window)) return;
      const u = new SpeechSynthesisUtterance(text);
      u.lang = lang;
      const v = getVoice(lang.split('-')[0]);
      if (v) u.voice = v;
      speechSynthesis.cancel();
      speechSynthesis.speak(u);
    }

    function loadRandomWord(){
      if (!words.length){
        wordText.textContent = transText.textContent = translationText.textContent = '---';
        setImageContent(null,null,null);
        return;
      }

      const idx = Math.floor(Math.random() * words.length);
      current = words[idx];
      revealed = false;

      wordText.textContent = current.word || '---';
      transText.textContent = current.transcription ? `[${current.transcription}]` : '---';
      translationText.textContent = current.translation || '---';

      setImageContent(current.image || null, current.translation, current.word);

      wordText.classList.remove('visible');
      transText.classList.remove('visible');
      speakENBtn.classList.remove('visible');
    }

    function reveal(){
      if (!revealed){
        wordText.classList.add('visible');
        transText.classList.add('visible');
        speakENBtn.classList.add('visible');
        revealed = true;
      }
    }

    speakENBtn.addEventListener('click', e => {
      e.stopPropagation();
      if (current && speakENBtn.classList.contains('visible'))
        speak(current.word, 'en-US');
    });

    speakRUBtn.addEventListener('click', e => {
      e.stopPropagation();
      if (current)
        speak(current.translation, 'ru-RU');
    });

    wordField.addEventListener('keydown', e => {
      if (e.key === 'Enter' || e.key === ' ') {
        e.preventDefault();
        reveal();
      }
    });

    wordField.addEventListener('click', reveal);

    nextBtn.addEventListener('click', () => {
      speechSynthesis.cancel();
      loadRandomWord();
    });

    (async function init(){
      await new Promise(resolve=>{
        let done=false;
        function tick(){
          if (speechSynthesis.getVoices().length){
            if(!done){done=true;resolve();}
          } else setTimeout(tick,80);
        }
        tick();
        setTimeout(()=>{if(!done){done=true;resolve();}},700);
      });

      await loadWords();
      loadRandomWord();
    })();

  </script>
</body>
</html>





